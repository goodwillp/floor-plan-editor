# Mathematical Concepts in BIM Wall System

## Overview

The BIM Wall System implements sophisticated geometric algorithms based on computational geometry principles used in professional CAD/BIM software. This guide explains the mathematical foundations behind the system's operations.

## Baseline Curve Offsetting

### Concept

Wall geometry is generated by offsetting a baseline curve by half the wall thickness on both sides. This approach ensures mathematical precision and follows industry standards.

### Mathematical Foundation

Given a baseline curve C(t) parameterized by t ∈ [0,1], the offset curves are calculated as:

```
C_left(t) = C(t) + (thickness/2) * N(t)
C_right(t) = C(t) - (thickness/2) * N(t)
```

Where N(t) is the unit normal vector perpendicular to the curve at parameter t.

### Implementation Details

```typescript
/**
 * Calculates offset curves using robust geometric algorithms
 * @param baseline - The baseline curve to offset
 * @param distance - Offset distance (typically thickness/2)
 * @param joinType - How to handle corners (miter, bevel, round)
 * @returns Left and right offset curves
 */
function offsetCurve(
  baseline: Curve, 
  distance: number, 
  joinType: OffsetJoinType
): OffsetResult {
  // Calculate normal vectors at each point
  const normals = calculateNormals(baseline);
  
  // Generate offset points
  const leftPoints = baseline.points.map((point, i) => ({
    x: point.x + distance * normals[i].x,
    y: point.y + distance * normals[i].y
  }));
  
  const rightPoints = baseline.points.map((point, i) => ({
    x: point.x - distance * normals[i].x,
    y: point.y - distance * normals[i].y
  }));
  
  // Handle corner joins based on local geometry
  return processCornerJoins(leftPoints, rightPoints, joinType);
}
```

### Join Types

#### Miter Join
Used for moderate angles (typically 30° to 150°). The offset lines are extended until they intersect.

**Mathematical Formula:**
```
Miter Point = intersection of lines L1 and L2
where L1 and L2 are the extended offset segments
```

#### Bevel Join
Used for sharp angles where miter would create excessive extensions. Creates a straight line connecting the offset endpoints.

#### Round Join
Creates a circular arc connecting the offset segments. The radius equals the offset distance.

## Boolean Operations

### Union Operation

Combines multiple wall solids into a single coherent geometry, resolving overlaps and intersections.

**Algorithm:**
1. Convert wall solids to polygon representations
2. Apply Martinez polygon clipping algorithm
3. Merge overlapping regions
4. Reconstruct wall solid from result

```typescript
/**
 * Performs boolean union on multiple wall solids
 * @param solids - Array of wall solids to union
 * @returns Combined wall solid
 */
function union(solids: WallSolid[]): BooleanResult {
  // Convert to Martinez polygon format
  const polygons = solids.map(solid => 
    wallSolidToMartinezPolygon(solid)
  );
  
  // Perform union operation
  let result = polygons[0];
  for (let i = 1; i < polygons.length; i++) {
    result = martinez.union(result, polygons[i]);
  }
  
  // Convert back to wall solid
  return martinezPolygonToWallSolid(result);
}
```

### Intersection Resolution

#### T-Junction Resolution

T-junctions occur when one wall terminates at another wall. Resolution involves:

1. **Miter Apex Calculation**: Find the intersection point of the offset lines
2. **Geometric Validation**: Ensure the intersection is geometrically valid
3. **Boolean Union**: Combine the wall solids at the intersection

**Mathematical Process:**
```typescript
/**
 * Resolves T-junction intersection using miter apex calculation
 * @param wall1 - The continuous wall
 * @param wall2 - The terminating wall
 * @returns Resolved intersection geometry
 */
function resolveTJunction(wall1: WallSolid, wall2: WallSolid): IntersectionData {
  // Find intersection point of baselines
  const baselineIntersection = findLineIntersection(
    wall1.baseline, 
    wall2.baseline
  );
  
  // Calculate miter apex for each offset pair
  const leftApex = findLineIntersection(
    wall1.leftOffset,
    wall2.leftOffset
  );
  
  const rightApex = findLineIntersection(
    wall1.rightOffset,
    wall2.rightOffset
  );
  
  // Create intersection geometry
  return createIntersectionGeometry(
    baselineIntersection,
    leftApex,
    rightApex
  );
}
```

#### L-Junction Resolution

L-junctions occur when two walls meet at their endpoints. The resolution process:

1. **Corner Angle Calculation**: Determine the angle between the walls
2. **Join Type Selection**: Choose miter, bevel, or round based on angle
3. **Geometric Construction**: Build the corner geometry

## Adaptive Tolerance Management

### Tolerance Calculation

Tolerances are dynamically calculated based on:
- Wall thickness
- Document precision
- Local geometry (angles, curvature)
- Operation type

**Formula:**
```typescript
/**
 * Calculates adaptive tolerance based on context
 * @param thickness - Wall thickness
 * @param precision - Document precision setting
 * @param angle - Local angle at the operation point
 * @param operationType - Type of geometric operation
 * @returns Calculated tolerance value
 */
function calculateTolerance(
  thickness: number,
  precision: number,
  angle: number,
  operationType: ToleranceContext
): number {
  // Base tolerance from thickness and precision
  const baseTolerance = Math.max(
    thickness * 0.001,  // 0.1% of thickness
    precision * 0.1     // 10% of document precision
  );
  
  // Angle-based adjustment
  const angleRadians = angle * Math.PI / 180;
  const angleFactor = Math.sin(angleRadians / 2);
  const angleAdjustment = 1 + (1 - angleFactor) * 2;
  
  // Operation-specific multiplier
  const operationMultiplier = getOperationMultiplier(operationType);
  
  return baseTolerance * angleAdjustment * operationMultiplier;
}
```

### Sharp Angle Handling

Sharp angles (< 30° or > 150°) require special handling to prevent numerical instability:

1. **Increased Tolerance**: Use larger snap radius for vertex merging
2. **Alternative Join Types**: Switch from miter to bevel/round
3. **Geometric Validation**: Extra validation for extreme cases

## Shape Healing Algorithms

### Sliver Face Removal

Sliver faces are thin polygonal faces that result from boolean operations. They're identified and removed based on:

**Aspect Ratio Test:**
```
aspect_ratio = max_dimension / min_dimension
if aspect_ratio > threshold: mark_as_sliver()
```

**Area Test:**
```
relative_area = face_area / total_area
if relative_area < threshold: mark_as_sliver()
```

### Vertex Merging

Non-consecutive vertices within tolerance are merged to simplify geometry:

```typescript
/**
 * Merges vertices that are within tolerance distance
 * @param vertices - Array of vertices to process
 * @param tolerance - Distance threshold for merging
 * @returns Simplified vertex array
 */
function mergeVertices(vertices: BIMPoint[], tolerance: number): BIMPoint[] {
  const merged: BIMPoint[] = [];
  const processed = new Set<number>();
  
  for (let i = 0; i < vertices.length; i++) {
    if (processed.has(i)) continue;
    
    const vertex = vertices[i];
    const mergeGroup = [vertex];
    
    // Find all vertices within tolerance
    for (let j = i + 1; j < vertices.length; j++) {
      if (processed.has(j)) continue;
      
      const distance = calculateDistance(vertex, vertices[j]);
      if (distance <= tolerance) {
        mergeGroup.push(vertices[j]);
        processed.add(j);
      }
    }
    
    // Calculate merged position (centroid)
    const mergedVertex = calculateCentroid(mergeGroup);
    merged.push(mergedVertex);
    processed.add(i);
  }
  
  return merged;
}
```

## Geometry Simplification

### Ramer-Douglas-Peucker (RDP) Algorithm

The RDP algorithm simplifies polylines by removing points that don't significantly contribute to the shape:

```typescript
/**
 * Simplifies a polyline using the RDP algorithm
 * @param points - Points to simplify
 * @param tolerance - Maximum allowed deviation
 * @returns Simplified point array
 */
function rdpSimplify(points: BIMPoint[], tolerance: number): BIMPoint[] {
  if (points.length <= 2) return points;
  
  // Find the point with maximum distance from line segment
  let maxDistance = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  
  for (let i = 1; i < points.length - 1; i++) {
    const distance = pointToLineDistance(points[i], start, end);
    if (distance > maxDistance) {
      maxDistance = distance;
      maxIndex = i;
    }
  }
  
  // If max distance is greater than tolerance, recursively simplify
  if (maxDistance > tolerance) {
    const left = rdpSimplify(points.slice(0, maxIndex + 1), tolerance);
    const right = rdpSimplify(points.slice(maxIndex), tolerance);
    
    // Combine results (remove duplicate middle point)
    return left.slice(0, -1).concat(right);
  } else {
    // All points are within tolerance, return endpoints only
    return [start, end];
  }
}
```

## Numerical Stability

### Floating Point Considerations

The system handles floating-point precision issues through:

1. **Epsilon Comparisons**: Use tolerance-based comparisons instead of exact equality
2. **Scaled Arithmetic**: Perform calculations in scaled coordinate systems
3. **Robust Predicates**: Use geometric predicates that handle edge cases

```typescript
/**
 * Robust floating-point comparison
 * @param a - First value
 * @param b - Second value
 * @param epsilon - Tolerance for comparison
 * @returns True if values are approximately equal
 */
function approximatelyEqual(a: number, b: number, epsilon: number): boolean {
  return Math.abs(a - b) <= epsilon * Math.max(1, Math.abs(a), Math.abs(b));
}
```

### Degenerate Case Handling

The system detects and handles degenerate cases:

- **Zero-length segments**: Removed before processing
- **Collinear points**: Simplified to reduce complexity
- **Self-intersecting curves**: Resolved using curve splitting
- **Extreme angles**: Handled with specialized algorithms

## Performance Optimization

### Spatial Indexing

R-tree spatial indexing accelerates geometric queries:

```typescript
/**
 * Spatial index for efficient geometric queries
 */
class SpatialIndex {
  private rtree: RTree;
  
  /**
   * Finds all walls intersecting with a bounding box
   * @param bbox - Query bounding box
   * @returns Array of potentially intersecting walls
   */
  query(bbox: BoundingBox): WallSolid[] {
    const candidates = this.rtree.search(bbox);
    return candidates.map(item => item.wall);
  }
  
  /**
   * Inserts a wall into the spatial index
   * @param wall - Wall to index
   */
  insert(wall: WallSolid): void {
    const bbox = calculateBoundingBox(wall);
    this.rtree.insert(bbox, { wall });
  }
}
```

### Computational Complexity

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| Offset Curve | O(n) | O(n) |
| Boolean Union | O(n log n) | O(n) |
| T-Junction Resolution | O(1) | O(1) |
| Shape Healing | O(n²) | O(n) |
| RDP Simplification | O(n²) worst, O(n log n) average | O(n) |

Where n is the number of vertices or geometric elements.

## References

1. **Computational Geometry: Algorithms and Applications** - de Berg, Cheong, van Kreveld, Overmars
2. **Real-Time Collision Detection** - Christer Ericson
3. **Geometric Tools for Computer Graphics** - Schneider, Eberly
4. **Martinez Polygon Clipping Library** - Francisco Martinez, Antonio Jesus Rueda, Francisco Ramon Feito
5. **OpenCASCADE Technology Documentation** - Open CASCADE SAS

## See Also

- [Performance Optimization Guide](./performance-optimization.md)
- [Error Handling Guide](./error-handling.md)
- [RobustOffsetEngine API](../engines/RobustOffsetEngine.md)
- [BooleanOperationsEngine API](../engines/BooleanOperationsEngine.md)